// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"elsenova/models"
)

func newSeed(db *gorm.DB, opts ...gen.DOOption) seed {
	_seed := seed{}

	_seed.seedDo.UseDB(db, opts...)
	_seed.seedDo.UseModel(&models.Seed{})

	tableName := _seed.seedDo.TableName()
	_seed.ALL = field.NewAsterisk(tableName)
	_seed.ID = field.NewUint(tableName, "id")
	_seed.CreatedAt = field.NewTime(tableName, "created_at")
	_seed.UpdatedAt = field.NewTime(tableName, "updated_at")
	_seed.DeletedAt = field.NewField(tableName, "deleted_at")
	_seed.Value = field.NewString(tableName, "value")

	_seed.fillFieldMap()

	return _seed
}

type seed struct {
	seedDo

	ALL       field.Asterisk
	ID        field.Uint
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Field
	Value     field.String

	fieldMap map[string]field.Expr
}

func (s seed) Table(newTableName string) *seed {
	s.seedDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s seed) As(alias string) *seed {
	s.seedDo.DO = *(s.seedDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *seed) updateTableName(table string) *seed {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewUint(table, "id")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")
	s.Value = field.NewString(table, "value")

	s.fillFieldMap()

	return s
}

func (s *seed) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *seed) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 5)
	s.fieldMap["id"] = s.ID
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
	s.fieldMap["value"] = s.Value
}

func (s seed) clone(db *gorm.DB) seed {
	s.seedDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s seed) replaceDB(db *gorm.DB) seed {
	s.seedDo.ReplaceDB(db)
	return s
}

type seedDo struct{ gen.DO }

type ISeedDo interface {
	gen.SubQuery
	Debug() ISeedDo
	WithContext(ctx context.Context) ISeedDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISeedDo
	WriteDB() ISeedDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISeedDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISeedDo
	Not(conds ...gen.Condition) ISeedDo
	Or(conds ...gen.Condition) ISeedDo
	Select(conds ...field.Expr) ISeedDo
	Where(conds ...gen.Condition) ISeedDo
	Order(conds ...field.Expr) ISeedDo
	Distinct(cols ...field.Expr) ISeedDo
	Omit(cols ...field.Expr) ISeedDo
	Join(table schema.Tabler, on ...field.Expr) ISeedDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISeedDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISeedDo
	Group(cols ...field.Expr) ISeedDo
	Having(conds ...gen.Condition) ISeedDo
	Limit(limit int) ISeedDo
	Offset(offset int) ISeedDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISeedDo
	Unscoped() ISeedDo
	Create(values ...*models.Seed) error
	CreateInBatches(values []*models.Seed, batchSize int) error
	Save(values ...*models.Seed) error
	First() (*models.Seed, error)
	Take() (*models.Seed, error)
	Last() (*models.Seed, error)
	Find() ([]*models.Seed, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Seed, err error)
	FindInBatches(result *[]*models.Seed, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.Seed) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISeedDo
	Assign(attrs ...field.AssignExpr) ISeedDo
	Joins(fields ...field.RelationField) ISeedDo
	Preload(fields ...field.RelationField) ISeedDo
	FirstOrInit() (*models.Seed, error)
	FirstOrCreate() (*models.Seed, error)
	FindByPage(offset int, limit int) (result []*models.Seed, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISeedDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s seedDo) Debug() ISeedDo {
	return s.withDO(s.DO.Debug())
}

func (s seedDo) WithContext(ctx context.Context) ISeedDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s seedDo) ReadDB() ISeedDo {
	return s.Clauses(dbresolver.Read)
}

func (s seedDo) WriteDB() ISeedDo {
	return s.Clauses(dbresolver.Write)
}

func (s seedDo) Session(config *gorm.Session) ISeedDo {
	return s.withDO(s.DO.Session(config))
}

func (s seedDo) Clauses(conds ...clause.Expression) ISeedDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s seedDo) Returning(value interface{}, columns ...string) ISeedDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s seedDo) Not(conds ...gen.Condition) ISeedDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s seedDo) Or(conds ...gen.Condition) ISeedDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s seedDo) Select(conds ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s seedDo) Where(conds ...gen.Condition) ISeedDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s seedDo) Order(conds ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s seedDo) Distinct(cols ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s seedDo) Omit(cols ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s seedDo) Join(table schema.Tabler, on ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s seedDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISeedDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s seedDo) RightJoin(table schema.Tabler, on ...field.Expr) ISeedDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s seedDo) Group(cols ...field.Expr) ISeedDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s seedDo) Having(conds ...gen.Condition) ISeedDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s seedDo) Limit(limit int) ISeedDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s seedDo) Offset(offset int) ISeedDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s seedDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISeedDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s seedDo) Unscoped() ISeedDo {
	return s.withDO(s.DO.Unscoped())
}

func (s seedDo) Create(values ...*models.Seed) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s seedDo) CreateInBatches(values []*models.Seed, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s seedDo) Save(values ...*models.Seed) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s seedDo) First() (*models.Seed, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.Seed), nil
	}
}

func (s seedDo) Take() (*models.Seed, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.Seed), nil
	}
}

func (s seedDo) Last() (*models.Seed, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.Seed), nil
	}
}

func (s seedDo) Find() ([]*models.Seed, error) {
	result, err := s.DO.Find()
	return result.([]*models.Seed), err
}

func (s seedDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Seed, err error) {
	buf := make([]*models.Seed, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s seedDo) FindInBatches(result *[]*models.Seed, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s seedDo) Attrs(attrs ...field.AssignExpr) ISeedDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s seedDo) Assign(attrs ...field.AssignExpr) ISeedDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s seedDo) Joins(fields ...field.RelationField) ISeedDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s seedDo) Preload(fields ...field.RelationField) ISeedDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s seedDo) FirstOrInit() (*models.Seed, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.Seed), nil
	}
}

func (s seedDo) FirstOrCreate() (*models.Seed, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.Seed), nil
	}
}

func (s seedDo) FindByPage(offset int, limit int) (result []*models.Seed, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s seedDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s seedDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s seedDo) Delete(models ...*models.Seed) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *seedDo) withDO(do gen.Dao) *seedDo {
	s.DO = *do.(*gen.DO)
	return s
}
